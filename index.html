<!doctype html>
<html lang="en">
  <head>
	<meta name="generator" content="Hugo 0.102.3" />
    <meta charset="utf-8">
<title>Linux Kernel Slide</title>
<meta name="description" content="A Hugo theme for creating Reveal.js presentations">
<meta name="author" content="Josh Dzielak">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="/reveal-js/css/reset.css">
<link rel="stylesheet" href="/reveal-js/css/reveal.css"><link rel="stylesheet" href="/reveal-hugo/themes/robot-lung.css" id="theme"><link rel="stylesheet" href="/highlight-js/color-brewer.min.css">
    

<style>
 
.reveal section pre {
  box-shadow: none;
  margin-top: 25px;
  margin-bottom: 25px;
  border: 1px solid lightgrey;
}
.reveal section pre:hover {
  border: 1px solid grey;
  transition: border 0.3s ease;
}
.reveal section pre > code {
  padding: 10px;
}
.reveal table {
  font-size: 0.65em;
}
 
.reveal section.side-by-side h1 {
  position: absolute;
}
.reveal section.side-by-side h1:first-of-type {
  left: 25%;
}
.reveal section.side-by-side h1:nth-of-type(2) {
  right: 25%;
}
.reveal section[data-background-image] a,
.reveal section[data-background-image] p,
.reveal section[data-background-image] h2 {
  color: white;
}
.reveal section[data-background-image] a {
  text-decoration: underline;
}
</style>

  </head>
  <body>
    
    <div class="reveal">
      <div class="slides">
  

    <section><h3 id="dude-do-you-even-audit-">Dude, Do you even audit? ğŸ§</h3>
<img src="000-dude.png" alt="Dude, Do you even audit? ğŸ§" width="480">
<br>
ì§€ê¸ˆ ì´ ìˆœê°„, Linux Auditing System ìŠˆí¼ ìœ ì € & ë‚´ë¶€ êµ¬ì¡° ì˜ì•Œ!
<p><strong>Paran Lee</strong> <strong>&lt;<a href="mailto:p4ranlee@gmail.com">p4ranlee@gmail.com</a>&gt;</strong></p>
</section>

  

    <section><h2 id="index">Index</h2>
<ul>
<li>
<ol>
<li>audit ì„ ì–´ë–»ê²Œ í™œìš©í• ê¹Œ?</li>
</ol>
<ul>
<li>1.1 í° ê·¸ë¦¼</li>
<li>1.2 man</li>
<li>1.3 audit ìŠˆí¼ ìœ ì €ê°€ ë˜ê¸°</li>
</ul>
</li>
<li>
<ol start="2">
<li>ë¦¬ëˆ…ìŠ¤ ì»¤ë„ audit ë‚´ë¶€ êµ¬ì¡° ë¶„ì„!</li>
</ol>
<ul>
<li>2.1. ì–¸ì œ ì–´ë–»ê²Œ ì´ˆê¸°í™” ë˜ëŠ”ê°€?</li>
<li>2.2. <strong>audit.log</strong> ë¡œê·¸ì— ì°íˆê¸°ê¹Œì§€</li>
<li>2.3. <strong>audit rule</strong> ì„ ì–´ë–»ê²Œ ë¡œë“œí• ê¹Œ?</li>
</ul>
</li>
<li>
<ol start="3">
<li>ì°¸ê³ </li>
</ol>
</li>
</ul>
</section><section>
<h3 id="1-audit-ì„-ì–´ë–»ê²Œ-í™œìš©í• ê¹Œ-">1. audit ì„ ì–´ë–»ê²Œ í™œìš©í• ê¹Œ? ğŸ¤”</h3>
<ul>
<li>ğŸ¤” ì–´ë–»ê²Œ ì¦ê±°(ë¡œê·¸)ë¥¼ ë‚¨ê¸°ë©´ ì¢‹ì„ê¹Œìš”?
<ul>
<li>ìŠ¤í† ë¦¬ì§€ ì„œë²„ <em><code>/opt</code> ë””ë ‰í† ë¦¬ ì•ˆì— ì¤‘ìš”í•œ íŒŒì¼ì„ ëˆ„ê°€ ì§€ìš°ì…¨ì–´ìš¥!?</em></li>
<li>ì»¨í…Œì´ë„ˆ ì•ˆì— <em>ì´ìƒí•œ ì†Œí”„íŠ¸ì›¨ì–´ê°€ ìê¾¸ ì„¤ì¹˜ë˜ìš”. ëˆ„ê°€ ì„¤ì¹˜í•œê±°ì£ ..?</em></li>
<li>ì‚¬ë‚´ <em>ì†ŒìŠ¤ ì„œë²„ì— ìê¾¸ ì´ìƒí•œ IP ê°€ ì ‘ê·¼í•©ë‹ˆë‹¤. ì´ëŸ¬ë‹¤ê°€ ì „ë¶€ DRM ê±¸ë¦¬ê±°ë‚˜ ì†ŒìŠ¤ ì½¸ì½¸ì½¸ ìœ ì¶œ ì•„ë‹ˆê² ì£ ?!</em></li>
</ul>
</li>
</ul>
<h4 id="ê³ ë¯¼í•˜ì§€-ë§ê³ -audit-ì„-ì‚¬ìš©í•´ë´…ì‹œë‹¤">ê³ ë¯¼í•˜ì§€ ë§ê³ , audit ì„ ì‚¬ìš©í•´ë´…ì‹œë‹¤!</h4>
</section><section>
<h3 id="1-audit-ì„-ì–´ë–»ê²Œ-í™œìš©í• ê¹Œ--1">1. audit ì„ ì–´ë–»ê²Œ í™œìš©í• ê¹Œ? ğŸ¤”</h3>
<ul>
<li><strong>audit ì„ ì˜ ì‚¬ìš©í•˜ê¸° ìœ„í•œ ì‚¬ìš©ë²•, ê·¸ë¦¬ê³  ì»¤ë„/ìœ ì € ë™ì‘ê³¼ ì†Œí”„íŠ¸ì›¨ì–´ ì»´í¬ë„ŒíŠ¸ëŠ” ì–´ë–»ê²Œ êµ¬ì„±ë˜ì–´ ìˆëŠ”ì§€ ì‚´í´ë´…ë‹ˆë‹¤.</strong></li>
</ul>
<img src="000-audit-logging.png" alt="audit_components" width="600">
</section><section>
<h3 id="11-í°-ê·¸ë¦¼">1.1 í° ê·¸ë¦¼</h3>
<ul>
<li>ìœ ì € í”„ë¡œì„¸ìŠ¤ê°€ í•˜ëŠ” í–‰ë™ì˜ ë¡œê·¸ë¥¼ ë‚¨ê¸°ê¸° ìœ„í•œ ì»¤ë„ í”„ë¡œì„¸ìŠ¤ kaudit ì™€ ìœ ì € libaudit í”„ë ˆì„ì›Œí¬ë¥¼ í™œìš©í•œ ì†Œí”„íŠ¸ì›¨ì–´ ì¸í”„ë¼ì…ë‹ˆë‹¤.</li>
</ul>
<img src="000-audit_components.png" alt="audit_components" width="600">
<ul>
<li>ì»¤ë„ ìŠ¤í˜ì´ìŠ¤ì˜ audit lsm hook ë¡œ ctx -&gt; audit_context -&gt; skb</li>
<li>netlink ë¡œ auditd ì™€ í†µì‹ í•˜ë©° í–‰ë™ ë¡œê¹… ë° ìƒˆë¡œìš´ ë£°ì„ ì ìš©í•©ë‹ˆë‹¤.</li>
</ul>
</section><section>
<h3 id="11-ì£¼ìš”-íŠ¹ì§•">1.1 ì£¼ìš” íŠ¹ì§•</h3>
<ul>
<li>ì»¤ë„ í”„ë¡œì„¸ìŠ¤ë¡œ ìƒì£¼ ì¤‘ì¸ kaudit ì€ <strong>security/lsm_audit.c</strong> Hook ì„ ì‚¬ìš©í•˜ì—¬ ctx ì •ë³´ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.</li>
<li>auditd ê°€ ì˜¬ë¼ì˜¤ë©´ì„œ <strong>audit.rules</strong> íŒŒì¼ì„ ì½ì–´ ì •ì±…ì„ ì ìš©í•©ë‹ˆë‹¤.</li>
<li>auditctl ë¡œ ìš´ì˜ ì¤‘ì¸ ì‹œìŠ¤í…œì— ì ìš©í•©ë‹ˆë‹¤.</li>
<li>ì•„í‚¤í…ì³ ì§€ì› : arm, x86, s390 (32, 64 bit)
<ul>
<li><a href="https://github.com/linux-audit/audit-userspace/blob/v3.0.9/lib/aarch64_table.h">aarch64_table.h</a></li>
</ul>
</li>
<li>ë¦¬ëˆ…ìŠ¤ ì»¤ë„ ì‹œìŠ¤í…œ ì½œ í…Œì´ë¸”ì˜ ìƒˆë¡œìš´ ì‹œìŠ¤í…œ ì½œì„ íŒ”ë¡œìš° ì—… í•©ë‹ˆë‹¤.
<ul>
<li>(ì˜ˆ) <code>_S(280, &quot;bpf&quot;)</code> audit 3.0 BPF ì‹œìŠ¤í…œ ì½œ ê°ì‚¬ ì •ì±… ì§€ì›</li>
<li>Add <a href="https://man7.org/linux/man-pages/man2/bpf.2.html">bpf syscall</a> command argument interpretation to auparse</li>
<li>í˜¸ìŠ¤íŠ¸ ë¨¸ì‹ ì—ì„œ virtual machine, container ê°ì‹œ ê´€ë ¨ feature ë¥¼ í™•ì¥ ì¤‘ì…ë‹ˆë‹¤.</li>
</ul>
</li>
<li>audit ì€ ë¹¨ê°„ ëª¨ìì˜ ì•ˆë³´ê°€ ì¤‘ìš”í•œ ì„œë²„ ì†”ë£¨ì…˜ì—ì„œ <a href="https://ko.wikipedia.org/wiki/%EC%B9%A8%EC%9E%85_%ED%83%90%EC%A7%80_%EC%8B%9C%EC%8A%A4%ED%85%9C">ì¹¨ì… íƒì§€ ì‹œìŠ¤í…œ(Intrusion Detection System)</a>ìœ¼ë¡œ í™œìš© ì¤‘ì…ë‹ˆë‹¤.</li>
</ul>
</section><section>
<h3 id="12-man">1.2 man</h3>
<ul>
<li>auditd ëŠ” ìœ ì € ê³µê°„ Linux Auditing System ì…ë‹ˆë‹¤.
<ul>
<li>audit recordsë¥¼ ë””ìŠ¤í¬ì— ì“°ëŠ” ì„ë¬´ë¥¼ ë§¡ì€ ì¹œêµ¬ì£ .</li>
</ul>
</li>
<li>ë¡œê·¸ëŠ” ausearch ë˜ëŠ” aureport ë¥¼ í†µí•˜ì—¬ í¸ë¦¬í•˜ê²Œ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
<li>auditctl ì„ í†µí•´ ìš´ì˜ ì¤‘ì— audit ì„¤ì •ì„ ë°”ê¾¸ê±°ë‚˜ ë£°ì„ ë³€ê²½í•  ìˆ˜ ìˆì–´ìš”!</li>
<li>augenrules ì€ /etc/audit/rules.d/ ì•ˆì— ìˆëŠ” ë£° íŒŒì¼ë“¤ì„ <em>/etc/audit/audit.rules</em> íŒŒì¼ë¡œ ë§Œë“¤ì–´ ì¤ë‹ˆë‹¤.</li>
<li>auditd.conf ì„¤ì •ì„ ë°”ê¾¸ì–´ì„œ auditd ë¥¼ ì…ë§›ëŒ€ë¡œ ì„¤ì •í•  ìˆ˜ ìˆì–´ìš”!</li>
</ul>
</section><section>
<h3 id="13-audit-ìŠˆí¼-ìœ ì €ê°€-ë˜ê¸°---ì‹¤í–‰-í™•ì¸í•˜ê¸°">1.3 audit ìŠˆí¼ ìœ ì €ê°€ ë˜ê¸° - ì‹¤í–‰ í™•ì¸í•˜ê¸°</h3>
<pre><code class="language-bash"># service auditd status
Redirecting to /bin/systemctl status auditd.service
â— auditd.service - Security Auditing Service
   Loaded: loaded (/usr/lib/systemd/system/auditd.service; enabled; vendor preset: enabled)
   Active: active (running) since Wed 2022-09-28 01:42:53 KST; 54min ago
     Docs: man:auditd(8)
           https://github.com/linux-audit/audit-documentation
 Main PID: 1014 (auditd)
    Tasks: 4 (limit: 49134)
   Memory: 3.6M
   CGroup: /system.slice/auditd.service
           â”œâ”€1014 /sbin/auditd
           â””â”€1016 /usr/sbin/sedispatch

 9ì›” 28 01:42:53 localhost.localdomain augenrules[1033]: enabled 1
 9ì›” 28 01:42:53 localhost.localdomain augenrules[1033]: failure 1
 9ì›” 28 01:42:53 localhost.localdomain augenrules[1033]: pid 1014
 9ì›” 28 01:42:53 localhost.localdomain augenrules[1033]: rate_limit 0
 9ì›” 28 01:42:53 localhost.localdomain augenrules[1033]: backlog_limit 8192
 9ì›” 28 01:42:53 localhost.localdomain augenrules[1033]: lost 0
 9ì›” 28 01:42:53 localhost.localdomain augenrules[1033]: backlog 4
 9ì›” 28 01:42:53 localhost.localdomain augenrules[1033]: backlog_wait_time 60000
 9ì›” 28 01:42:53 localhost.localdomain augenrules[1033]: backlog_wait_time_actual 0
 9ì›” 28 01:42:53 localhost.localdomain systemd[1]: Started Security Auditing Service.
</code></pre>
<ul>
<li>ë¦¬ëˆ…ìŠ¤ ì»¤ë„ì˜ kauditd</li>
<li>ìœ ì € ìŠ¤í˜ì´ìŠ¤ì˜ ë ˆë“œí–‡/ë°ë¹„ì•ˆ ê³„ì—´ ë°°í¬íŒ auditd ë¡œ í™œì„±í™” ë˜ì–´ìˆìŠµë‹ˆë‹¤.</li>
</ul>
</section><section>
<h3 id="13-audit-ìŠˆí¼-ìœ ì €ê°€-ë˜ê¸°---ì‹¤í–‰-í™•ì¸í•˜ê¸°-1">1.3 audit ìŠˆí¼ ìœ ì €ê°€ ë˜ê¸° - ì‹¤í–‰ í™•ì¸í•˜ê¸°</h3>
<pre><code># ë ˆë“œí–‡ ê³„ì—´ # dnf install auditd
# ë°ë¹„ì•ˆ ê³„ì—´ # apt install auditd
</code></pre>
</section><section>
<h3 id="13-audit-ìŠˆí¼-ìœ ì €ê°€-ë˜ê¸°---aureport">1.3 audit ìŠˆí¼ ìœ ì €ê°€ ë˜ê¸° - aureport</h3>
<p>ssh ì ‘ê·¼, ì¦‰ sshd fork í•˜ì—¬ ìœ ì €ê°€ ë¡œê·¸ì¸í•˜ëŠ” í–‰ìœ„ì˜ ë¡œê·¸ë¥¼ ë´ ë³¼ê¹Œìš”!</p>
<pre><code class="language-bash">#  aureport -l --failed

Login Report
============================================
# date time auid host term exe success event
============================================
1. 2022ë…„ 09ì›” 28ì¼ 05:33:54 (unknown) 192.168.66.1 ssh /usr/sbin/sshd no 205
2. 2022ë…„ 09ì›” 28ì¼ 05:33:54 (unknown) 192.168.66.1 ssh /usr/sbin/sshd no 216
3. 2022ë…„ 09ì›” 28ì¼ 05:34:06 (unknown) 192.168.66.1 ssh /usr/sbin/sshd no 227
4. 2022ë…„ 09ì›” 28ì¼ 05:35:44 ahnlab 192.168.66.1 ssh /usr/sbin/sshd no 268
5. 2022ë…„ 09ì›” 28ì¼ 05:35:44 ahnlab 192.168.66.1 ssh /usr/sbin/sshd no 281
</code></pre>
<pre><code class="language-bash">#  aureport -l --success

Login Report
============================================
# date time auid host term exe success event
============================================
1. 2022ë…„ 09ì›” 28ì¼ 04:47:43 1000 ::1 /dev/pts/1 /usr/sbin/sshd yes 208
2. 2022ë…„ 09ì›” 28ì¼ 05:35:38 1000 192.168.66.1 /dev/pts/1 /usr/sbin/sshd yes 245
3. 2022ë…„ 09ì›” 28ì¼ 05:35:46 1000 192.168.66.1 ssh /usr/sbin/sshd yes 299
</code></pre>
</section><section>
<h3 id="13-audit-ìŠˆí¼-ìœ ì €ê°€-ë˜ê¸°---file-rule">1.3 audit ìŠˆí¼ ìœ ì €ê°€ ë˜ê¸° - file rule</h3>
<ul>
<li>ì™¸ë¶€ì—ì„œ /etc/ssh/sshd_config íŒŒì¼ì„ ì½ê±°ë‚˜ ìˆ˜ì •í•˜ë ¤ëŠ” ëª¨ë“  ì‹œë„ë¥¼ ë‚¨ê²¨ë³¼ê¹Œìš”?</li>
<li>í•´ë‹¹ rule ì„ sshd_config í‚¤ë¡œ ê¸°ë¡í•´ë³´ì£ !</li>
</ul>
<pre><code class="language-bash"> $ auditctl -w /etc/ssh/sshd_config -p warx -k sshd_config
</code></pre>
<pre><code class="language-bash"> $ # ausearch -k sshd_config
----
time-&gt;Wed Sep 28 06:04:31 2022
type=SYSCALL msg=audit(1664312671.115:387): arch=c000003e syscall=44 success=yes exit=1088 a0=4 a1=7ffc4fcb9be0 a2=440 a3=0 items=0 ppid=7613 pid=52609 auid=1000 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=pts0 ses=3 comm=&quot;auditctl&quot; exe=&quot;/usr/sbin/auditctl&quot; subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key=(null)
type=CONFIG_CHANGE msg=audit(1664312671.115:387): auid=1000 ses=3 subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 op=add_rule key=&quot;sshd_config&quot; list=4 res=1
----
time-&gt;Wed Sep 28 06:04:46 2022
type=PATH msg=audit(1664312686.595:388): item=0 name=&quot;/etc/ssh/sshd_config&quot; inode=103004708 dev=fd:00 mode=0100600 ouid=0 ogid=0 rdev=00:00 obj=system_u:object_r:etc_t:s0 nametype=NORMAL cap_fp=0 cap_fi=0 cap_fe=0 cap_fver=0 cap_frootid=0
type=SYSCALL msg=audit(1664312686.595:388): arch=c000003e syscall=257 success=yes exit=3 a0=ffffff9c a1=55dbad3cf050 a2=0 a3=0 items=1 ppid=7613 pid=53627 auid=1000 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=pts0 ses=3 comm=&quot;vim&quot; exe=&quot;/usr/bin/vim&quot; subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key=&quot;sshd_config&quot;
</code></pre>
</section><section>
<h3 id="13-audit-ìŠˆí¼-ìœ ì €ê°€-ë˜ê¸°---record-type">1.3 audit ìŠˆí¼ ìœ ì €ê°€ ë˜ê¸° - record type</h3>
<ul>
<li>type=SYSCALL
<ul>
<li>type í•„ë“œì—ëŠ” ë ˆì½”ë“œ ìœ í˜•ì´ í¬í•¨ë©ë‹ˆë‹¤. ì´ ì˜ˆì œì—ì„œ SYSCALL ê°’ì€ ì»¤ë„ì— ëŒ€í•œ ì‹œìŠ¤í…œ í˜¸ì¶œì— ì˜í•´ ì´ ë ˆì½”ë“œê°€ íŠ¸ë¦¬ê±°ë˜ì—ˆìŒì„ ì§€ì •í•©ë‹ˆë‹¤.</li>
</ul>
</li>
<li>key=&ldquo;sshd_config&rdquo;
<ul>
<li>í‚¤ í•„ë“œëŠ” ê°ì‚¬ ë¡œê·¸ì—ì„œ ì´ ì´ë²¤íŠ¸ë¥¼ ìƒì„±í•œ ê·œì¹™ê³¼ ê´€ë ¨ëœ ê´€ë¦¬ì ì •ì˜ ë¬¸ìì—´ì„ ê¸°ë¡í•©ë‹ˆë‹¤.</li>
</ul>
</li>
</ul>
<pre><code class="language-bash">type=SYSCALL msg=audit(1364481363.243:24287): arch=c000003e
syscall=2 success=no exit=-13 
a0=7fffd19c5592 a1=0 a2=7fffd19c4b50 a3=a items=1 
ppid=2686 pid=3538 auid=1000 
uid=1000 gid=1000 euid=1000 suid=1000 fsuid=1000 egid=1000 sgid=1000 fsgid=1000 
tty=pts0 ses=1 comm=&quot;cat&quot; exe=&quot;/bin/cat&quot; 
subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 
key=&quot;sshd_config&quot;
</code></pre>
</section><section>
<h3 id="13-audit-ìŠˆí¼-ìœ ì €ê°€-ë˜ê¸°---record-type-1">1.3 audit ìŠˆí¼ ìœ ì €ê°€ ë˜ê¸° - record type</h3>
<ul>
<li>ppid=2686
<ul>
<li>ppid í•„ë“œëŠ” ìƒìœ„ í”„ë¡œì„¸ìŠ¤ ID(PPID)ë¥¼ ê¸°ë¡í•©ë‹ˆë‹¤. ì´ ê²½ìš° 2686 ì€ bash ì™€ ê°™ì€ ìƒìœ„ í”„ë¡œì„¸ìŠ¤ì˜ PPIDì˜€ìŠµë‹ˆë‹¤.</li>
</ul>
</li>
<li>pid=3538
<ul>
<li>pid í•„ë“œëŠ” í”„ë¡œì„¸ìŠ¤ ID(PID)ë¥¼ ê¸°ë¡í•©ë‹ˆë‹¤. ì´ ê²½ìš° 3538 ì€ cat í”„ë¡œì„¸ìŠ¤ì˜ PIDì…ë‹ˆë‹¤.</li>
</ul>
</li>
<li>auid=1000
<ul>
<li>auid í•„ë“œëŠ” loginuidì¸ Audit ì‚¬ìš©ì IDë¥¼ ê¸°ë¡í•©ë‹ˆë‹¤. ì´ IDëŠ” ë¡œê·¸ì¸ ì‹œ ì‚¬ìš©ìì—ê²Œ í• ë‹¹ë˜ë©°,
ì˜ˆë¥¼ ë“¤ì–´ su - john ëª…ë ¹ìœ¼ë¡œ ì‚¬ìš©ì ê³„ì •ì„ ì „í™˜í•˜ì—¬ ì‚¬ìš©ìì˜ IDê°€ ë³€ê²½ë  ê²½ìš°ì—ë„ ëª¨ë“  í”„ë¡œì„¸ìŠ¤ì— ìƒì†ë©ë‹ˆë‹¤.</li>
</ul>
</li>
</ul>
<pre><code class="language-bash">type=SYSCALL msg=audit(1364481363.243:24287): arch=c000003e
syscall=2 success=no exit=-13 a0=7fffd19c5592 a1=0 a2=7fffd19c4b50 a3=a items=1 
ppid=2686 pid=3538 auid=1000 uid=1000 gid=1000 euid=1000
suid=1000 fsuid=1000 egid=1000 sgid=1000 fsgid=1000 
tty=pts0 ses=1 comm=&quot;cat&quot; exe=&quot;/bin/cat&quot; 
subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key=&quot;sshd_config&quot;
</code></pre>
</section><section>
<h3 id="13-audit-ìŠˆí¼-ìœ ì €ê°€-ë˜ê¸°---network-rule">1.3 audit ìŠˆí¼ ìœ ì €ê°€ ë˜ê¸° - network rule</h3>
<ul>
<li>ìœ ì…, ìœ ì¶œë˜ëŠ” ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
<ul>
<li>172.20.14.41:60822 ì—ì„œ í˜„ì¬ localhost ë¡œ ì ‘ê·¼ì„ í™•ì¸ ê°€ëŠ¥í•©ë‹ˆë‹¤!</li>
</ul>
</li>
</ul>
<pre><code class="language-bash"> $ auditctl -a always,exit -F arch=b64 -S accept,connect -F key=external-access
</code></pre>
<pre><code class="language-bash">type=PROCTITLE msg=audit(2022ë…„ 08ì›” 02ì¼ 09:47:19.345:372385) : 
proctitle=/usr/sbin/lighttpd -f /etc/lighttpd/lighttpd.conf
type=SOCKADDR msg=audit(2022ë…„ 08ì›” 02ì¼ 09:47:19.345:372385) : 
saddr={ fam=inet laddr=172.20.14.41 lport=60822 }
type=SYSCALL msg=audit(2022ë…„ 08ì›” 02ì¼ 09:47:19.345:372385) : 
arch=x86_64 syscall=accept success=yes exit=11 
a0=0x4 a1=0x7fffffffe870 a2=0x7fffffffe844 a3=0x3e8 
items=0 ppid=1 pid=22267 auid=unset uid=lighttpd gid=lighttpd 
euid=lighttpd suid=lighttpd fsuid=lighttpd egid=lighttpd sgid=lighttpd 
fsgid=lighttpd tty=(none) ses=unset comm=lighttpd 
exe=/usr/sbin/lighttpd key=my_accept
</code></pre>
</section><section>
<h3 id="13-audit-ìŠˆí¼-ìœ ì €ê°€-ë˜ê¸°---process-rule">1.3 audit ìŠˆí¼ ìœ ì €ê°€ ë˜ê¸° - process rule</h3>
<ul>
<li>ì¼ë°˜ ì‚¬ìš©ìì˜ rootë¡œ ê¶Œí•œ ìƒìŠ¹ ì‹œë„ë¥¼ í™•ì¸í•´ë³¼ê¹Œìš”?</li>
</ul>
<pre><code class="language-bash"> $ auditctl -a always,exit -F arch=b64 -S execve -C uid!=euid -F euid=0 -F key=10.2.5.b-elevated-privs-setuid
</code></pre>
<pre><code class="language-bash">type=SYSCALL msg=audit(1659428449.377:378871): arch=c000003e
syscall=59 success=yes exit=0 a0=6f4f60 a1=6fa4b0 a2=822900 a3=7fffffffe260
items=2 ppid=14078 pid=15495 auid=1052 uid=1052 gid=1052
euid=0 suid=0 fsuid=0 egid=1052 sgid=1052 fsgid=1052
tty=pts8 ses=26782 comm=&quot;su&quot; exe=&quot;/usr/bin/su&quot;
key=&quot;10.2.5.b-elevated-privs-setuid&quot; 
---
type=USER_AUTH msg=audit(1659428456.960:378872): pid=15495 uid=1052 auid=1052 ses=26782
msg='op=PAM:authentication grantors=pam_faillock,pam_unix acct=&quot;root&quot; exe=&quot;/usr/bin/su&quot; hostname=localhost.localdomain addr=? terminal=pts/8 res=success'
</code></pre>
<ul>
<li>ì´ì™¸ì—ë„ ì‹œìŠ¤í…œ ë£° ì˜ˆì‹œë¥¼ ì¡°ê¸ˆ ë” ì‚´í´ë³¼ë ¤ë©´? <strong><a href="https://github.com/linux-audit/audit-userspace/blob/v3.0.9/rules/30-stig.rules">30-stig.rules</a></strong> ì°¸ê³ !
<ul>
<li>Security Technical Implementation (STIG, ë¯¸êµ­ êµ­ë°©ì„±ì˜ DISA ë³´ì•ˆ êµ¬ì„± í‘œì¤€)ì—ì„œ ìš”êµ¬í•˜ëŠ” ì¡°ê±´ì„ ì¶©ì¡±í•  ìˆ˜ ìˆë„ë¡ êµ¬ì„±ëœ Audit ê·œì¹™ì…ë‹ˆë‹¤.</li>
</ul>
</li>
</ul>
</section><section>
<h3 id="13-audit-ìŠˆí¼-ìœ ì €ê°€-ë˜ê¸°---config">1.3 audit ìŠˆí¼ ìœ ì €ê°€ ë˜ê¸° - config</h3>
<p>ê¸°ë³¸ ì„¤ì •ì€ ì•„ë˜ì™€ ê°™ì´ í™•ì¸ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
<ul>
<li>event buffer ì‚¬ì´ì¦ˆ 8192</li>
<li>burst of events ì‹œì— 60000 ë§Œí¼ ê¸°ë‹¤ë¦°ë‹¤.</li>
</ul>
<pre><code># cat /etc/audit/rules.d/audit.rules 
## First rule - delete all
-D

## Increase the buffers to survive stress events.
## Make this bigger for busy systems
-b 8192

## This determine how long to wait in burst of events
--backlog_wait_time 60000

## Set failure mode to syslog
-f 1
</code></pre>
<pre><code># cat /etc/audit/audit.rules
## This file is automatically generated from /etc/audit/rules.d
-D
-b 8192
-f 1
--backlog_wait_time 60000
</code></pre>
</section>
    <section><h3 id="2-ë¦¬ëˆ…ìŠ¤-ì»¤ë„-kauditd-ë‚´ë¶€-êµ¬ì¡°-ë¶„ì„">2. ë¦¬ëˆ…ìŠ¤ ì»¤ë„ kauditd ë‚´ë¶€ êµ¬ì¡° ë¶„ì„!</h3>
<ul>
<li>kaudit ì˜ ì¤‘ìš”í•œ ë¶€ë¶„ì„ ì½• ì°ë¨¹í•´ë³¼ ì‹œê°„ì…ë‹ˆë‹¤.</li>
</ul>
</section><section>
<h3 id="21-kaduit-ì–¸ì œ-ì–´ë–»ê²Œ-ì´ˆê¸°í™”-ë ê¹Œìš”">2.1. kaduit ì–¸ì œ ì–´ë–»ê²Œ ì´ˆê¸°í™” ë ê¹Œìš”?</h3>
<pre><code>-&gt; arch_call_rest_init()
  -&gt; rest_init()
    -&gt; pid = kernel_thread(kernel_init, NULL, CLONE_FS);
      -&gt; kernel_init()
        -&gt; kernel_init_freeable()
          -&gt; do_basic_setup()
            -&gt; do_initcalls()
</code></pre>
<ul>
<li>do_initcalls() ë‚´ì˜ Linux ì»¤ë„ ë¶€íŒ… ì¤‘ ì´ˆê¸°í™” í˜¸ì¶œ ìƒëŒ€ì  ìˆœì„œë¥¼ ì‚´í´ë³´ë©´, 3ë²ˆì§¸ì— í•´ë‹¹í•˜ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
<ul>
<li>early_initcall(), core_initcall()</li>
<li><strong>postcore_initcall()</strong> â†’ <strong>postcore_initcall(audit_init);</strong></li>
<li>arch_initcall(), subsys_initcall(), fs_initcall(), device_initcall()</li>
</ul>
</li>
</ul>
</section><section>
<h3 id="21-kaduit-ì–¸ì œ-ì–´ë–»ê²Œ-ì´ˆê¸°í™”-ë ê¹Œìš”-1">2.1. kaduit ì–¸ì œ ì–´ë–»ê²Œ ì´ˆê¸°í™” ë ê¹Œìš”?</h3>
<pre><code class="language-bash"># dmesg | grep audit
[    0.215458] audit: initializing netlink subsys (disabled)
[    0.215500] audit: type=2000 audit(1664301355.215:1): state=initialized audit_enabled=0 res=1
[    7.430702] audit: type=1404 audit(1664301363.005:2): enforcing=1 old_enforcing=0 auid=4294967295 ses=4294967295 enabled=1 old-enabled=1 lsm=selinux res=1
[    7.786790] audit: type=1403 audit(1664301363.360:3): auid=4294967295 ses=4294967295 lsm=selinux res=1
</code></pre>
<pre><code class="language-bash">$ ps -ef | grep audit
root          69       2  0 09:29 ?        00:00:00 [kauditd]
root        1038       1  0 09:29 ?        00:00:00 /sbin/auditd
</code></pre>
</section><section>
<h3 id="21-kaduit-ì–¸ì œ-ì–´ë–»ê²Œ-ì´ˆê¸°í™”-ë ê¹Œìš”-2">2.1. kaduit ì–¸ì œ ì–´ë–»ê²Œ ì´ˆê¸°í™” ë ê¹Œìš”?</h3>
<ul>
<li><strong>audit_init()</strong> ë‹¤ìŒ í•­ëª©ì— ì£¼ëª©í•´ì„œ ë³´ë©´ ì–´ë–¨ê¹Œìš”?
<ul>
<li>skb_queue ìë£Œêµ¬ì¡° audit_queue</li>
<li>kauditd_thread(), audit_log()</li>
</ul>
</li>
</ul>
<pre><code class="language-c">/* Initialize audit support at boot time. */
static int __init audit_init(void)
{
	int i;

	if (audit_initialized == AUDIT_DISABLED)
		return 0;

	audit_buffer_cache = kmem_cache_create(&quot;audit_buffer&quot;,
					       sizeof(struct audit_buffer),
					       0, SLAB_PANIC, NULL);

	skb_queue_head_init(&amp;audit_queue);
	skb_queue_head_init(&amp;audit_retry_queue);
	skb_queue_head_init(&amp;audit_hold_queue);

	for (i = 0; i &lt; AUDIT_INODE_BUCKETS; i++)
		INIT_LIST_HEAD(&amp;audit_inode_hash[i]);
	// ...
	audit_initialized = AUDIT_INITIALIZED;

	kauditd_task = kthread_run(kauditd_thread, NULL, &quot;kauditd&quot;);
	// ...
	audit_log(NULL, GFP_KERNEL, AUDIT_KERNEL,
		&quot;state=initialized audit_enabled=%u res=1&quot;,
		 audit_enabled);

	return 0;
}
</code></pre>
<ul>
<li>í ìë£Œêµ¬ì¡° ì´ˆê¸°í™” ë° kauditd ì»¤ë„ ìŠ¤ë ˆë“œì˜ ìƒì„±ì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
</ul>
</section><section>
<h3 id="22-auditlog-ë¡œê·¸ì—-ì°íˆê¸°ê¹Œì§€">2.2. <strong>audit.log</strong> ë¡œê·¸ì— ì°íˆê¸°ê¹Œì§€</h3>
<ul>
<li>syscall_trace_enter -&gt; audit_syscall_entry ê³µí†µ í›…
<ul>
<li><a href="https://elixir.bootlin.com/linux/latest/source/arch/arm64">arch/arm64/kernel/ptrace.c</a></li>
</ul>
</li>
</ul>
<pre><code class="language-c">int syscall_trace_enter(struct pt_regs *regs)
{
	unsigned long flags = read_thread_flags();

	if (flags &amp; (_TIF_SYSCALL_EMU | _TIF_SYSCALL_TRACE)) {
		report_syscall(regs, PTRACE_SYSCALL_ENTER);
		if (flags &amp; _TIF_SYSCALL_EMU)
			return NO_SYSCALL;
	}

	/* Do the secure computing after ptrace; failures should be fast. */
	if (secure_computing() == -1)
		return NO_SYSCALL;

	if (test_thread_flag(TIF_SYSCALL_TRACEPOINT))
		trace_sys_enter(regs, regs-&gt;syscallno);

	audit_syscall_entry(regs-&gt;syscallno, regs-&gt;orig_x0, regs-&gt;regs[1],
			    regs-&gt;regs[2], regs-&gt;regs[3]);

	return regs-&gt;syscallno;
}
</code></pre>
</section><section>
<h3 id="22-auditlog-ë¡œê·¸ì—-ì°íˆê¸°ê¹Œì§€-1">2.2. <strong>audit.log</strong> ë¡œê·¸ì— ì°íˆê¸°ê¹Œì§€</h3>
<ul>
<li>syscall_trace_exit -&gt; audit_syscall_exit ê³µí†µ í›…
<ul>
<li><a href="https://elixir.bootlin.com/linux/latest/source/arch/arm64">arch/arm64/kernel/ptrace.c</a></li>
</ul>
</li>
</ul>
<pre><code class="language-c">void syscall_trace_exit(struct pt_regs *regs)
{
	unsigned long flags = read_thread_flags();

	audit_syscall_exit(regs);

	if (flags &amp; _TIF_SYSCALL_TRACEPOINT)
		trace_sys_exit(regs, syscall_get_return_value(current, regs));

	if (flags &amp; (_TIF_SYSCALL_TRACE | _TIF_SINGLESTEP))
		report_syscall(regs, PTRACE_SYSCALL_EXIT);

	rseq_syscall(regs);
}

</code></pre>
</section><section>
<h3 id="22-auditlog-ë¡œê·¸ì—-ì°íˆê¸°ê¹Œì§€-2">2.2. <strong>audit.log</strong> ë¡œê·¸ì— ì°íˆê¸°ê¹Œì§€</h3>
<ul>
<li><strong>struct common_audit_data</strong> : ê³µí†µ lsm audit log ì„ ìœ„í•œ data êµ¬ì¡°ì²´</li>
</ul>
<pre><code class="language-c">/* Auxiliary data to use in generating the audit record. */
struct common_audit_data {
	union 	{
		struct path path;
		struct dentry *dentry;
		struct inode *inode;
		struct lsm_network_audit *net;
		int cap;
		int ipc_id;
		struct task_struct *tsk;
		char *kmod_name;
		struct lsm_ioctlop_audit *op;
		struct file *file;
		struct lsm_ibpkey_audit *ibpkey;
		struct lsm_ibendport_audit *ibendport;
		int reason;
		const char *anonclass;
	} u;
}
</code></pre>
</section><section>
<h3 id="22-auditlog-ë¡œê·¸ì—-ì°íˆê¸°ê¹Œì§€-3">2.2. <strong>audit.log</strong> ë¡œê·¸ì— ì°íˆê¸°ê¹Œì§€</h3>
<ul>
<li><strong>common_lsm_audit()</strong> : Hook ì—ì„œ audit í•˜ê¸° ìœ„í•´ ì‚¬ìš©í•  í•¨ìˆ˜</li>
</ul>
<pre><code class="language-c">/**
 * common_lsm_audit - generic LSM auditing function
 * @a:  auxiliary audit data
 * @pre_audit: lsm-specific pre-audit callback
 * @post_audit: lsm-specific post-audit callback
 *
 * setup the audit buffer for common security information
 * uses callback to print LSM specific information
 */
void common_lsm_audit(struct common_audit_data *a,
	void (*pre_audit)(struct audit_buffer *, void *),
	void (*post_audit)(struct audit_buffer *, void *))
{
	struct audit_buffer *ab;

	if (a == NULL)
		return;
	/* we use GFP_ATOMIC so we won't sleep */
	ab = audit_log_start(audit_context(), GFP_ATOMIC | __GFP_NOWARN,
			     AUDIT_AVC);

	if (ab == NULL)
		return;

	if (pre_audit)
		pre_audit(ab, a);

	dump_common_audit_data(ab, a);

	if (post_audit)
		post_audit(ab, a);

	audit_log_end(ab);
}
</code></pre>
</section><section>
<h3 id="22-auditlog-ë¡œê·¸ì—-ì°íˆê¸°ê¹Œì§€-4">2.2. <strong>audit.log</strong> ë¡œê·¸ì— ì°íˆê¸°ê¹Œì§€</h3>
<ul>
<li><strong>audit_log_start()</strong> : struct audit_buffer ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë§Œë“¤ì–´ì¤ë‹ˆë‹¤.</li>
<li><strong>audit_log_end()</strong> : ë§Œë“  ë²„í¼ë¥¼ íì‰í•©ë‹ˆë‹¤.</li>
</ul>
<pre><code class="language-c">/* The audit_buffer is used when formatting an audit record.  The caller
 * locks briefly to get the record off the freelist or to allocate the
 * buffer, and locks briefly to send the buffer to the netlink layer or
 * to place it on a transmit queue.  Multiple audit_buffers can be in
 * use simultaneously. */
struct audit_buffer {
	struct sk_buff       *skb;	/* formatted skb ready to send */
	struct audit_context *ctx;	/* NULL or associated context */
	gfp_t		     gfp_mask;
};
</code></pre>
<pre><code class="language-c">/**
 * audit_log - Log an audit record
 * @ctx: audit context
 * @gfp_mask: type of allocation
 * @type: audit message type
 * @fmt: format string to use
 * @...: variable parameters matching the format string
 *
 * This is a convenience function that calls audit_log_start,
 * audit_log_vformat, and audit_log_end.  It may be called
 * in any context.
 */
void audit_log(struct audit_context *ctx, gfp_t gfp_mask, int type,
	       const char *fmt, ...)
{
	struct audit_buffer *ab;
	va_list args;

	ab = audit_log_start(ctx, gfp_mask, type);
	if (ab) {
		va_start(args, fmt);
		audit_log_vformat(ab, fmt, args);
		va_end(args);
		audit_log_end(ab);
	}
}
</code></pre>
<ul>
<li>ë¡œê·¸ë¥¼ ë§Œë“¤ê¸°ìœ„í•œ ë²„í¼ë¥¼ ì‚¬ìš©í•˜ëŠ” ë£¨í‹´ì„ í™•ì¸í•©ë‹ˆë‹¤.</li>
</ul>
</section><section>
<h3 id="22-auditlog-ë¡œê·¸ì—-ì°íˆê¸°ê¹Œì§€-5">2.2. <strong>audit.log</strong> ë¡œê·¸ì— ì°íˆê¸°ê¹Œì§€</h3>
<ul>
<li><strong>struct audit_context</strong> ë¥¼ ê°€ì§€ê³  <strong>struct audit_buffer</strong> ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë§Œë“¤ì–´ì¤ë‹ˆë‹¤.</li>
</ul>
<pre><code class="language-c">/**
 * audit_log_start - obtain an audit buffer
 * @ctx: audit_context (may be NULL)
 * @gfp_mask: type of allocation
 * @type: audit message type
 *
 * Returns audit_buffer pointer on success or NULL on error.
 *
 * Obtain an audit buffer.  This routine does locking to obtain the
 * audit buffer, but then no locking is required for calls to
 * audit_log_*format.  If the task (ctx) is a task that is currently in a
 * syscall, then the syscall is marked as auditable and an audit record
 * will be written at syscall exit.  If there is no associated task, then
 * task context (ctx) should be NULL.
 */
struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,
				     int type)
{
	struct audit_buffer *ab;
	struct timespec64 t;
	unsigned int serial;

	if (audit_initialized != AUDIT_INITIALIZED)
		return NULL;

	if (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))
		return NULL;

	/* NOTE: don't ever fail/sleep on these two conditions:
	 * 1. auditd generated record - since we need auditd to drain the
	 *    queue; also, when we are checking for auditd, compare PIDs using
	 *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()
	 *    using a PID anchored in the caller's namespace
	 * 2. generator holding the audit_cmd_mutex - we don't want to block
	 *    while holding the mutex, although we do penalize the sender
	 *    later in audit_receive() when it is safe to block
	 */
	if (!(auditd_test_task(current) || audit_ctl_owner_current())) {
		long stime = audit_backlog_wait_time;

		while (audit_backlog_limit &amp;&amp;
		       (skb_queue_len(&amp;audit_queue) &gt; audit_backlog_limit)) {
			/* wake kauditd to try and flush the queue */
			wake_up_interruptible(&amp;kauditd_wait);

			/* sleep if we are allowed and we haven't exhausted our
			 * backlog wait limit */
			if (gfpflags_allow_blocking(gfp_mask) &amp;&amp; (stime &gt; 0)) {
				long rtime = stime;

				DECLARE_WAITQUEUE(wait, current);

				add_wait_queue_exclusive(&amp;audit_backlog_wait,
							 &amp;wait);
				set_current_state(TASK_UNINTERRUPTIBLE);
				stime = schedule_timeout(rtime);
				atomic_add(rtime - stime, &amp;audit_backlog_wait_time_actual);
				remove_wait_queue(&amp;audit_backlog_wait, &amp;wait);
			} else {
				if (audit_rate_check() &amp;&amp; printk_ratelimit())
					pr_warn(&quot;audit_backlog=%d &gt; audit_backlog_limit=%d\n&quot;,
						skb_queue_len(&amp;audit_queue),
						audit_backlog_limit);
				audit_log_lost(&quot;backlog limit exceeded&quot;);
				return NULL;
			}
		}
	}

	ab = audit_buffer_alloc(ctx, gfp_mask, type);
	if (!ab) {
		audit_log_lost(&quot;out of memory in audit_log_start&quot;);
		return NULL;
	}

	audit_get_stamp(ab-&gt;ctx, &amp;t, &amp;serial);
	/* cancel dummy context to enable supporting records */
	if (ctx)
		ctx-&gt;dummy = 0;
	audit_log_format(ab, &quot;audit(%llu.%03lu:%u): &quot;,
			 (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);

	return ab;
}
</code></pre>
<ul>
<li><strong>Hook ì˜ ctx -&gt; audit_context -&gt; audit_buffer</strong></li>
</ul>
</section><section>
<h3 id="22-auditlog-ë¡œê·¸ì—-ì°íˆê¸°ê¹Œì§€-6">2.2. <strong>audit.log</strong> ë¡œê·¸ì— ì°íˆê¸°ê¹Œì§€</h3>
<ul>
<li><strong>struct audit_buffer</strong> ë¥¼ ê°€ì§€ê³  ë„·ë§í¬ í†µì‹ ì„ ìœ„í•œ sk_buff ë¥¼ ë§Œë“¤ê³ , audit_queue í…Œì¼ì— íì‰í•©ë‹ˆë‹¤.</li>
</ul>
<pre><code class="language-c">/**
 * audit_log_end - end one audit record
 * @ab: the audit_buffer
 *
 * We can not do a netlink send inside an irq context because it blocks (last
 * arg, flags, is not set to MSG_DONTWAIT), so the audit buffer is placed on a
 * queue and a kthread is scheduled to remove them from the queue outside the
 * irq context.  May be called in any context.
 */
void audit_log_end(struct audit_buffer *ab)
{
	struct sk_buff *skb;
	struct nlmsghdr *nlh;

	if (!ab)
		return;

	if (audit_rate_check()) {
		skb = ab-&gt;skb;
		ab-&gt;skb = NULL;

		/* setup the netlink header, see the comments in
		 * kauditd_send_multicast_skb() for length quirks */
		nlh = nlmsg_hdr(skb);
		nlh-&gt;nlmsg_len = skb-&gt;len - NLMSG_HDRLEN;

		/* queue the netlink packet and poke the kauditd thread */
		skb_queue_tail(&amp;audit_queue, skb);
		wake_up_interruptible(&amp;kauditd_wait);
	} else
		audit_log_lost(&quot;rate limit exceeded&quot;);

	audit_buffer_free(ab);
}
</code></pre>
<ul>
<li>queue the netlink packet and poke the kauditd thread</li>
</ul>
</section><section>
<h3 id="22-auditlog-ë¡œê·¸ì—-ì°íˆê¸°ê¹Œì§€-7">2.2. <strong>audit.log</strong> ë¡œê·¸ì— ì°íˆê¸°ê¹Œì§€</h3>
<ul>
<li>kthread ì—ì„œëŠ” irq context ë°–ì—ì„œ audit_queue ì²˜ë¦¬ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤!
<ul>
<li>audit buffer ëŠ” audit_queue ì— ë“¤ì–´ê°€êµ¬ìš”.</li>
<li>í”„ë¡œì„¸ìŠ¤ ì»¨í…ìŠ¤íŠ¸ì—ì„œ ì²˜ë¦¬í•´ì„œ í•¸ë“¤ë§ì´ ì‰¬ì›Œì§€ì£ !</li>
</ul>
</li>
</ul>
<pre><code class="language-c">/**
 * kauditd_thread - Worker thread to send audit records to userspace
 * @dummy: unused
 */
static int kauditd_thread(void *dummy)
{
	int rc;
	u32 portid = 0;
	struct net *net = NULL;
	struct sock *sk = NULL;
	struct auditd_connection *ac;

#define UNICAST_RETRIES 5

	set_freezable();
	while (!kthread_should_stop()) {
		/* NOTE: see the lock comments in auditd_send_unicast_skb() */
		rcu_read_lock();
		ac = rcu_dereference(auditd_conn);
		if (!ac) {
			rcu_read_unlock();
			goto main_queue;
		}
		net = get_net(ac-&gt;net);
		sk = audit_get_sk(net);
		portid = ac-&gt;portid;
		rcu_read_unlock();

		/* attempt to flush the hold queue */
		rc = kauditd_send_queue(sk, portid,
					&amp;audit_hold_queue, UNICAST_RETRIES,
					NULL, kauditd_rehold_skb);
		if (rc &lt; 0) {
			sk = NULL;
			auditd_reset(ac);
			goto main_queue;
		}

		/* attempt to flush the retry queue */
		rc = kauditd_send_queue(sk, portid,
					&amp;audit_retry_queue, UNICAST_RETRIES,
					NULL, kauditd_hold_skb);
		if (rc &lt; 0) {
			sk = NULL;
			auditd_reset(ac);
			goto main_queue;
		}

main_queue:
		/* process the main queue - do the multicast send and attempt
		 * unicast, dump failed record sends to the retry queue; if
		 * sk == NULL due to previous failures we will just do the
		 * multicast send and move the record to the hold queue */
		rc = kauditd_send_queue(sk, portid, &amp;audit_queue, 1,
					kauditd_send_multicast_skb,
					(sk ?
					 kauditd_retry_skb : kauditd_hold_skb));
		if (ac &amp;&amp; rc &lt; 0)
			auditd_reset(ac);
		sk = NULL;

		/* drop our netns reference, no auditd sends past this line */
		if (net) {
			put_net(net);
			net = NULL;
		}

		/* we have processed all the queues so wake everyone */
		wake_up(&amp;audit_backlog_wait);

		/* NOTE: we want to wake up if there is anything on the queue,
		 *       regardless of if an auditd is connected, as we need to
		 *       do the multicast send and rotate records from the
		 *       main queue to the retry/hold queues */
		wait_event_freezable(kauditd_wait,
				     (skb_queue_len(&amp;audit_queue) ? 1 : 0));
	}

	return 0;
}
</code></pre>
<ul>
<li>netlink ê¸°ë°˜ logger êµ¬í˜„ í•œë‹¤ë©´ ì°¸ê³ í•  ìˆ˜ ìˆëŠ” ì¢‹ì€ ì½”ë“œë„¤ìš”!</li>
</ul>
</section><section>
<h3 id="22-auditlog-ë¡œê·¸ì—-ì°íˆê¸°ê¹Œì§€-8">2.2. <strong>audit.log</strong> ë¡œê·¸ì— ì°íˆê¸°ê¹Œì§€</h3>
<ul>
<li><strong>kauditd_thread()</strong> ë‚´ë¶€ì—ì„œ ë³´ì•˜ë˜, ìœ ì € ìŠ¤í˜ì´ìŠ¤ë¡œ netlink ì†Œì¼“ìœ¼ë¡œ íŒ¨í‚·ì„ ì „ë‹¬í•˜ëŠ” ë¶€ë¶„ì…ë‹ˆë‹¤!</li>
</ul>
<pre><code class="language-c">/**
 * kauditd_send_queue - Helper for kauditd_thread to flush skb queues
 * @sk: the sending sock
 * @portid: the netlink destination
 * @queue: the skb queue to process
 * @retry_limit: limit on number of netlink unicast failures
 * @skb_hook: per-skb hook for additional processing
 * @err_hook: hook called if the skb fails the netlink unicast send
 *
 * Description:
 * Run through the given queue and attempt to send the audit records to auditd,
 * returns zero on success, negative values on failure.  It is up to the caller
 * to ensure that the @sk is valid for the duration of this function.
 *
 */
static int kauditd_send_queue(struct sock *sk, u32 portid,
			      struct sk_buff_head *queue,
			      unsigned int retry_limit,
			      void (*skb_hook)(struct sk_buff *skb),
			      void (*err_hook)(struct sk_buff *skb, int error))
{
	int rc = 0;
	struct sk_buff *skb = NULL;
	struct sk_buff *skb_tail;
	unsigned int failed = 0;

	/* NOTE: kauditd_thread takes care of all our locking, we just use
	 *       the netlink info passed to us (e.g. sk and portid) */

	skb_tail = skb_peek_tail(queue);
	while ((skb != skb_tail) &amp;&amp; (skb = skb_dequeue(queue))) {
		/* call the skb_hook for each skb we touch */
		if (skb_hook)
			(*skb_hook)(skb);

		/* can we send to anyone via unicast? */
		if (!sk) {
			if (err_hook)
				(*err_hook)(skb, -ECONNREFUSED);
			continue;
		}

retry:
		/* grab an extra skb reference in case of error */
		skb_get(skb);
		rc = netlink_unicast(sk, skb, portid, 0);
		if (rc &lt; 0) {
			/* send failed - try a few times unless fatal error */
			if (++failed &gt;= retry_limit ||
			    rc == -ECONNREFUSED || rc == -EPERM) {
				sk = NULL;
				if (err_hook)
					(*err_hook)(skb, rc);
				if (rc == -EAGAIN)
					rc = 0;
				/* continue to drain the queue */
				continue;
			} else
				goto retry;
		} else {
			/* skb sent - drop the extra reference and continue */
			consume_skb(skb);
			failed = 0;
		}
	}

	return (rc &gt;= 0 ? 0 : rc);
}
</code></pre>
<ul>
<li>íì‰í•œ audit_queue ì—ì„œ skb ë¥¼ get í•˜ê³ , ì´ë¥¼ netlink ë¡œ ì „ë‹¬í•©ë‹ˆë‹¤.</li>
</ul>
</section><section>
<h3 id="22-auditlog-ë¡œê·¸ì—-ì°íˆê¸°ê¹Œì§€-9">2.2. <strong>audit.log</strong> ë¡œê·¸ì— ì°íˆê¸°ê¹Œì§€</h3>
<ul>
<li><strong>struct audit_context</strong> ë©¤ë²„ë¥¼ ìŠ¬ì© ë³¼ê¹Œìš”! ìì„¸í•œ ì„¤ëª…ì€ ìƒëµ!</li>
</ul>
<pre><code class="language-c">/* The per-task audit context. */
struct audit_context {
	int		    dummy;	/* must be the first element */
	enum {
		AUDIT_CTX_UNUSED,	/* audit_context is currently unused */
		AUDIT_CTX_SYSCALL,	/* in use by syscall */
		AUDIT_CTX_URING,	/* in use by io_uring */
	} context;
	enum audit_state    state, current_state;
	unsigned int	    serial;     /* serial number for record */
	int		    major;      /* syscall number */
	int		    uring_op;   /* uring operation */
	struct timespec64   ctime;      /* time of syscall entry */
	unsigned long	    argv[4];    /* syscall arguments */
	long		    return_code;/* syscall return code */
	u64		    prio;
	int		    return_valid; /* return code is valid */
	/*
	 * The names_list is the list of all audit_names collected during this
	 * syscall.  The first AUDIT_NAMES entries in the names_list will
	 * actually be from the preallocated_names array for performance
	 * reasons.  Except during allocation they should never be referenced
	 * through the preallocated_names array and should only be found/used
	 * by running the names_list.
	 */
	struct audit_names  preallocated_names[AUDIT_NAMES];
	int		    name_count; /* total records in names_list */
	struct list_head    names_list;	/* struct audit_names-&gt;list anchor */
	char		    *filterkey;	/* key for rule that triggered record */
	struct path	    pwd;
	struct audit_aux_data *aux;
	struct audit_aux_data *aux_pids;
	struct sockaddr_storage *sockaddr;
	size_t sockaddr_len;
				/* Save things to print about task_struct */
	pid_t		    pid, ppid;
	kuid_t		    uid, euid, suid, fsuid;
	kgid_t		    gid, egid, sgid, fsgid;
	unsigned long	    personality;
	int		    arch;

	pid_t		    target_pid;
	kuid_t		    target_auid;
	kuid_t		    target_uid;
	unsigned int	    target_sessionid;
	u32		    target_sid;
	char		    target_comm[TASK_COMM_LEN];

	struct audit_tree_refs *trees, *first_trees;
	struct list_head killed_trees;
	int tree_count;

	int type;
	union {
		struct {
			int nargs;
			long args[6];
		} socketcall;
		struct {
			kuid_t			uid;
			kgid_t			gid;
			umode_t			mode;
			u32			osid;
			int			has_perm;
			uid_t			perm_uid;
			gid_t			perm_gid;
			umode_t			perm_mode;
			unsigned long		qbytes;
		} ipc;
		struct {
			mqd_t			mqdes;
			struct mq_attr		mqstat;
		} mq_getsetattr;
		struct {
			mqd_t			mqdes;
			int			sigev_signo;
		} mq_notify;
		struct {
			mqd_t			mqdes;
			size_t			msg_len;
			unsigned int		msg_prio;
			struct timespec64	abs_timeout;
		} mq_sendrecv;
		struct {
			int			oflag;
			umode_t			mode;
			struct mq_attr		attr;
		} mq_open;
		struct {
			pid_t			pid;
			struct audit_cap_data	cap;
		} capset;
		struct {
			int			fd;
			int			flags;
		} mmap;
		struct open_how openat2;
		struct {
			int			argc;
		} execve;
		struct {
			char			*name;
		} module;
		struct {
			struct audit_ntp_data	ntp_data;
			struct timespec64	tk_injoffset;
		} time;
	};
	int fds[2];
	struct audit_proctitle proctitle;
};
</code></pre>
<ul>
<li>The per-task audit context.</li>
</ul>
<pre><code class="language-c">static inline void audit_set_context(struct task_struct *task, struct audit_context *ctx)
{
	task-&gt;audit_context = ctx;
}

static inline struct audit_context *audit_context(void)
{
	return current-&gt;audit_context;
}
</code></pre>
<p>&ndash; task_struct ì— audit_context ë©¤ë²„ê°€ ìˆìŠµë‹ˆë‹¤.</p>
</section><section>
<h3 id="23-audit-rule-ì„-ì–´ë–»ê²Œ-ë¡œë“œí• ê¹Œ">2.3. audit rule ì„ ì–´ë–»ê²Œ ë¡œë“œí• ê¹Œ?</h3>
<ul>
<li>ìœ ì € ìŠ¤í˜ì´ìŠ¤ : auditd</li>
</ul>
<pre><code class="language-c">int audit_add_rule_data(int fd, struct audit_rule_data *rule,
                        int flags, int action)
{
	int rc;

	rule-&gt;flags  = flags;
	rule-&gt;action = action;
	rc = audit_send(fd, AUDIT_ADD_RULE, rule,
			sizeof(struct audit_rule_data) + rule-&gt;buflen);
</code></pre>
</section><section>
<h3 id="23-audit-rule-ì„-ì–´ë–»ê²Œ-ë¡œë“œí• ê¹Œ-1">2.3. audit rule ì„ ì–´ë–»ê²Œ ë¡œë“œí• ê¹Œ?</h3>
<ul>
<li>ì»¤ë„ ìŠ¤í˜ì´ìŠ¤ : kaduditd</li>
</ul>
<pre><code class="language-c">/**
 * audit_receive - receive messages from a netlink control socket
 * @skb: the message buffer
 *
 * Parse the provided skb and deal with any messages that may be present,
 * malformed skbs are discarded.
 */
static void audit_receive(struct sk_buff  *skb)
{
	struct nlmsghdr *nlh;
	/*
	 * len MUST be signed for nlmsg_next to be able to dec it below 0
	 * if the nlmsg_len was not aligned
	 */
	int len;
	int err;

	nlh = nlmsg_hdr(skb);
	len = skb-&gt;len;

	audit_ctl_lock();
	while (nlmsg_ok(nlh, len)) {
		err = audit_receive_msg(skb, nlh);
</code></pre>
<ul>
<li>ë£°ì€ ìœ„ì˜ ë¡œì§ì„ í†µí•´ì„œ ìœ ì €ì—ì„œ ì»¤ë„ë¡œ ì˜¬ë¼ì˜´ì„ í™•ì¸í•©ë‹ˆë‹¤!</li>
</ul>
</section>
    <section><h3 id="2-ìœ ì €-ìŠ¤í˜ì´ìŠ¤-auditd-ì½¤í¬ë„ŒíŠ¸-ë¶„ì„">2. ìœ ì € ìŠ¤í˜ì´ìŠ¤ auditd ì½¤í¬ë„ŒíŠ¸ ë¶„ì„!</h3>
<ul>
<li>auditd ì˜ ì¤‘ìš”í•œ ë¶€ë¶„ì„ ì½• ì°ë¨¹í•´ë³¼ ì‹œê°„ì…ë‹ˆë‹¤.</li>
</ul>
</section><section>
<h3 id="21-auditd-ì–¸ì œ-ì–´ë–»ê²Œ-ì´ˆê¸°í™”-í• ê¹Œìš”">2.1. auditd ì–¸ì œ ì–´ë–»ê²Œ ì´ˆê¸°í™” í• ê¹Œìš”?</h3>
<ul>
<li><a href="https://github.com/linux-audit/audit-userspace/blob/v3.0.9/src/auditd.c">auditd.c - main()</a> ì½• ì°ì–´ë³¼ê¹Œìš”?</li>
</ul>
<pre><code class="language-c">
	/* Load the Configuration File */
	if (load_config(&amp;config, TEST_AUDITD))

	/* Init netlink */
	if ((fd = audit_open())

	// Init complete, start event loop
	if (!stop)
		ev_loop (loop, 0);

</code></pre>
<pre><code class="language-c">int audit_open(void)
{
	int fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_AUDIT);

</code></pre>
</section><section>
<h3 id="22-ê°ì‚¬-ì •ì±…ì„-ì–´ë–»ê²Œ-ë¡œë“œí• ê¹Œìš”">2.2. ê°ì‚¬ ì •ì±…ì„ ì–´ë–»ê²Œ ë¡œë“œí• ê¹Œìš”?</h3>
<p>auditd ë°ëª¬ì„ ì§ì ‘ ë§Œë“¤ì–´ë³¼ê¹Œìš”? libaudit + auditd ë‚´ë¶€ì—ì„œë„ ì‚¬ìš©í•˜ëŠ” libev ë¡œ~</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

#include &lt;libaudit.h&gt;

#include &lt;ev.h&gt;

static int fd;

void monitoring(struct ev_loop *loop, struct ev_io *io, int revents) {
    struct audit_reply reply;

    audit_get_reply(fd, &amp;reply, GET_REPLY_NONBLOCKING, 0);

    if (reply.type != AUDIT_EOE &amp;&amp;
            reply.type != AUDIT_PROCTITLE &amp;&amp;
            reply.type != AUDIT_PATH) {
        printf(&quot;Event: Type=%s Message=%.*s\n&quot;,
                     audit_msg_type_to_name(reply.type),
                     reply.len,
                     reply.message);
    }
}

int main() {
    fd = audit_open();
    struct audit_rule_data* rule = new audit_rule_data();

    // ë””ë ‰í† ë¦¬ì— ëŒ€í•œ ê°ì‹œëŠ” ë‹¤ìŒê³¼ ê°™ì€ API ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
    //  audit_add_watch_dir(AUDIT_DIR, &amp;rule, &quot;bitcoin&quot;);

    audit_add_watch(&amp;rule, &quot;bitcoin/wallet.dat&quot;);

    // ì…‹ì—…í•œ ë£°ì„ auditd ì— ë„˜ê²¨ì¤ë‹ˆë‹¤.
    audit_add_rule_data(fd, rule, AUDIT_FILTER_USER, AUDIT_ALWAYS);
    struct ev_io monitor;
    audit_set_pid(fd, getpid(), WAIT_YES);

    audit_set_enabled(fd, 1);
    struct ev_loop *loop = ev_default_loop(EVFLAG_NOENV);

    ev_io_init(&amp;monitor, monitoring, fd, EV_READ);
    ev_io_start(loop, &amp;monitor);

    // wallet.dat íŒŒì¼ì— ì´ë²¤íŠ¸ê°€ ì˜¤ëŠ”ì§€ í™•ì¸í•˜ë©´ì„œ ê°ì‹œí•©ë‹ˆë‹¤.
    ev_loop(loop, 0);

    audit_close(fd);
    return 0;
}
</code></pre>
</section><section>
<h3 id="ì£¼ìš”-ë¦´ë¦¬ì¦ˆ-ë³€ê²½">ì£¼ìš” ë¦´ë¦¬ì¦ˆ ë³€ê²½</h3>
<p>2020-12-17 audit 3.0 ë¦´ë¦¬ì¦ˆë¶€í„°ëŠ” ê¸°ì¡´ audispd ì´ë²¤íŠ¸ ë””ìŠ¤íŒ¨ì³ ë°ëª¬ì„ auditd ë¡œ í†µí•©í–ˆìŠµë‹ˆë‹¤.</p>
<p>This is the long awaited 3.0 major feature release. Most notable item is that audispd is gone.</p>
<ul>
<li>Merge auditd and audispd code</li>
<li>Move all audispd config files under /etc/audit/</li>
<li>Move audispd.conf settings into auditd.conf</li>
</ul>
</section>
    <section><h3 id="todo">TODO</h3>
<pre><code>Future roadmap (subject to change):
===================================
3.1
* Basic HIDS based on reactive audit component
* Multi-thread audisp-remote
* Add keywords for time: month-ago, this-hour, last-hour
* If searching user/group doesn't map to uid/gid, do translated string search
* In auditd, look into non-blocking handling of write to plugins
* Support multiple time streams when searching

3.2
* Container support
* Support TLS PSK as remote logging transport
* Add rule verify to detect mismatch between in-kernel and on-disk rules
* audisp-remote, add config to say what home network is so 
  laptops don't try if their not on a network that can reach the server.
* Fix audit.pc.in to use Requires.private
* Change ausearch to output name=&quot;&quot; unless its a real null.
  (mount) ausearch-report.c, 523. FIXME
* Fix SIGHUP for auditd network settings
* Add ability to filter events in auditd
</code></pre>
</section><section>
<h1 id="heading">ğŸ¤—</h1>
<p>ì´ìƒì…ë‹ˆë‹¤. ^^7 ê³ ìƒí•˜ì…¨ìŠµë‹ˆë‹¤!</p>
</section><section>
<h3 id="ì°¸ê³ ">ì°¸ê³ </h3>
<ul>
<li><a href="https://people.redhat.com/sgrubb/audit/">Steve Grubb(Redhat) - Linux Audit</a></li>
<li><a href="http://security-plus-data-science.blogspot.com/">Steve Grubb Blog - Security + Data Science</a></li>
<li><a href="https://izyknows.medium.com/linux-auditd-for-threat-detection-d06c8b941505">Linux auditd for Threat Hunting [Part 1]</a></li>
<li><a href="https://docs.kernel.org/security/lsm-development.html">Security hooks for Audit</a></li>
<li><a href="https://documentation.suse.com/sles/15-SP1/html/SLES-all/part-audit.html#">SLES 15-SP1 - Part VI The Linux Audit Framework</a></li>
<li><a href="https://people.redhat.com/sgrubb/audit/audit-ids.pdf">Audit and IDS - Red Hat People</a></li>
<li><a href="https://www.youtube.com/watch?v=w-XN9PGlMDc">Tracking User and System activity with Oracle Linux Auditing</a></li>
<li><a href="https://stopdisablingselinux.com/">Stop disabling SELinux</a></li>
</ul>
</section><section>
<h3 id="miscaudit-package">misc(audit package)</h3>
<pre><code># rpm -ql audit
/etc/audit
/etc/audit/audit-stop.rules
/etc/audit/audit.rules
/etc/audit/auditd.conf
/etc/audit/plugins.d
/etc/audit/plugins.d/af_unix.conf
/etc/audit/rules.d
/etc/audit/rules.d/audit.rules
/usr/bin/aulast
/usr/bin/aulastlog
/usr/bin/ausyscall
/usr/bin/auvirt
/usr/lib/.build-id
/usr/lib/.build-id/0a
/usr/lib/.build-id/0a/54a2aeda2ce2f0cc9c789ab94afde974ea3ddf
/usr/lib/.build-id/15
/usr/lib/.build-id/15/be5ccbbd0ba37fea823d161d849a3d48671c64
/usr/lib/.build-id/2d
/usr/lib/.build-id/2d/733d5160c5a1ef08df0c709fb7436df2e3a548
/usr/lib/.build-id/3f
/usr/lib/.build-id/3f/bf084e6e5e599ac11ef7055de93519681e0d78
/usr/lib/.build-id/4a
/usr/lib/.build-id/4a/0842df3b270ee02070f848d05b8c6a456f7e64
/usr/lib/.build-id/4b
/usr/lib/.build-id/4b/f99725734e3834085ca9078cf97988a5d63ded
/usr/lib/.build-id/57
/usr/lib/.build-id/57/32c733d13c22aa5737b7ca085ec59191ef385e
/usr/lib/.build-id/cb
/usr/lib/.build-id/cb/4d2ae2ccacd7d5bcd9629242ab76b0e780988a
/usr/lib/.build-id/d7
/usr/lib/.build-id/d7/58719c24909e850832714a422496ddb894b08a
/usr/lib/systemd/system/auditd.service
/usr/libexec/audit-functions
/usr/libexec/initscripts/legacy-actions/auditd
/usr/libexec/initscripts/legacy-actions/auditd/condrestart
/usr/libexec/initscripts/legacy-actions/auditd/reload
/usr/libexec/initscripts/legacy-actions/auditd/restart
/usr/libexec/initscripts/legacy-actions/auditd/resume
/usr/libexec/initscripts/legacy-actions/auditd/rotate
/usr/libexec/initscripts/legacy-actions/auditd/state
/usr/libexec/initscripts/legacy-actions/auditd/stop
/usr/sbin/auditctl
/usr/sbin/auditd
/usr/sbin/augenrules
/usr/sbin/aureport
/usr/sbin/ausearch
/usr/sbin/autrace
/usr/share/audit
/usr/share/audit/sample-rules
/usr/share/audit/sample-rules/10-base-config.rules
/usr/share/audit/sample-rules/10-no-audit.rules
/usr/share/audit/sample-rules/11-loginuid.rules
/usr/share/audit/sample-rules/12-cont-fail.rules
/usr/share/audit/sample-rules/12-ignore-error.rules
/usr/share/audit/sample-rules/20-dont-audit.rules
/usr/share/audit/sample-rules/21-no32bit.rules
/usr/share/audit/sample-rules/22-ignore-chrony.rules
/usr/share/audit/sample-rules/23-ignore-filesystems.rules
/usr/share/audit/sample-rules/30-nispom.rules
/usr/share/audit/sample-rules/30-ospp-v42-1-create-failed.rules
/usr/share/audit/sample-rules/30-ospp-v42-1-create-success.rules
/usr/share/audit/sample-rules/30-ospp-v42-2-modify-failed.rules
/usr/share/audit/sample-rules/30-ospp-v42-2-modify-success.rules
/usr/share/audit/sample-rules/30-ospp-v42-3-access-failed.rules
/usr/share/audit/sample-rules/30-ospp-v42-3-access-success.rules
/usr/share/audit/sample-rules/30-ospp-v42-4-delete-failed.rules
/usr/share/audit/sample-rules/30-ospp-v42-4-delete-success.rules
/usr/share/audit/sample-rules/30-ospp-v42-5-perm-change-failed.rules
/usr/share/audit/sample-rules/30-ospp-v42-5-perm-change-success.rules
/usr/share/audit/sample-rules/30-ospp-v42-6-owner-change-failed.rules
/usr/share/audit/sample-rules/30-ospp-v42-6-owner-change-success.rules
/usr/share/audit/sample-rules/30-ospp-v42.rules
/usr/share/audit/sample-rules/30-pci-dss-v31.rules
/usr/share/audit/sample-rules/30-stig.rules
/usr/share/audit/sample-rules/31-privileged.rules
/usr/share/audit/sample-rules/32-power-abuse.rules
/usr/share/audit/sample-rules/40-local.rules
/usr/share/audit/sample-rules/41-containers.rules
/usr/share/audit/sample-rules/42-injection.rules
/usr/share/audit/sample-rules/43-module-load.rules
/usr/share/audit/sample-rules/44-installers.rules
/usr/share/audit/sample-rules/70-einval.rules
/usr/share/audit/sample-rules/71-networking.rules
/usr/share/audit/sample-rules/99-finalize.rules
/usr/share/audit/sample-rules/README-rules
/usr/share/doc/audit
/usr/share/doc/audit/ChangeLog
/usr/share/doc/audit/README
/usr/share/doc/audit/auditd.cron
/usr/share/licenses/audit
/usr/share/licenses/audit/COPYING
/usr/share/man/man5/auditd-plugins.5.gz
/usr/share/man/man5/auditd.conf.5.gz
/usr/share/man/man5/ausearch-expression.5.gz
/usr/share/man/man7/audit.rules.7.gz
/usr/share/man/man8/auditctl.8.gz
/usr/share/man/man8/auditd.8.gz
/usr/share/man/man8/augenrules.8.gz
/usr/share/man/man8/aulast.8.gz
/usr/share/man/man8/aulastlog.8.gz
/usr/share/man/man8/aureport.8.gz
/usr/share/man/man8/ausearch.8.gz
/usr/share/man/man8/ausyscall.8.gz
/usr/share/man/man8/autrace.8.gz
/usr/share/man/man8/auvirt.8.gz
/var/log/audit
/var/run/auditd.state
</code></pre>
</section><section>
<h3 id="miscaudit-package-1">misc(audit package)</h3>
<pre><code># dnf search audit
ë§ˆì§€ë§‰ ë©”íƒ€ìë£Œ ë§Œë£Œí™•ì¸ 0:04:14 ì´ì „ì¸: 2022ë…„ 09ì›” 28ì¼ (ìˆ˜) ì˜¤ì „ 03ì‹œ 03ë¶„ 55ì´ˆ.
=========================== ì´ë¦„ &amp; ìš”ì•½ê³¼ ì¼ì¹˜í•˜ëŠ” í•­ëª©: audit ============================
audit.x86_64 : User space tools for kernel auditing
audit.src : User space tools for kernel auditing
audit-debuginfo.i686 : Debug information for package audit
audit-debuginfo.x86_64 : Debug information for package audit
audit-debugsource.i686 : Debug sources for package audit
audit-debugsource.x86_64 : Debug sources for package audit
audit-libs.x86_64 : Dynamic library for libaudit
audit-libs.i686 : Dynamic library for libaudit
audit-libs-debuginfo.i686 : Debug information for package audit-libs
audit-libs-debuginfo.x86_64 : Debug information for package audit-libs
audit-libs-devel.i686 : Header files for libaudit
audit-libs-devel.x86_64 : Header files for libaudit
pgaudit-debuginfo.x86_64 : Debug information for package pgaudit
pgaudit-debugsource.x86_64 : Debug sources for package pgaudit
python3-audit.x86_64 : Python3 bindings for libaudit
python3-audit-debuginfo.i686 : Debug information for package python3-audit
python3-audit-debuginfo.x86_64 : Debug information for package python3-audit
rsyslog-mmaudit.x86_64 : Message modification module supporting Linux audit format
rsyslog-mmaudit-debuginfo.x86_64 : Debug information for package rsyslog-mmaudit
sos-audit.noarch : Audit use of some commands for support purposes
=============================== ìš”ì•½ê³¼ ì¼ì¹˜í•˜ëŠ” í•­ëª©: audit ===============================
</code></pre>
</section>
    <section><p>ìœ ì € UID ë¥¼ í†µí•œ í™•ì¸ ë°©ë²•</p>
<pre><code class="language-bash"># ausearch -ui $UID --interpret
----
type=DAEMON_START msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:53.647:2054) : op=start ver=3.0.7 format=enriched kernel=4.18.0-394.el8.x86_64 auid=unset pid=1014 uid=root ses=unset subj=system_u:system_r:auditd_t:s0 res=success 
----
type=SERVICE_START msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:53.666:5) : pid=1 uid=root auid=unset ses=unset subj=system_u:system_r:init_t:s0 msg='unit=rpcbind comm=systemd exe=/usr/lib/systemd/systemd hostname=? addr=? terminal=? res=success' 
----
type=PROCTITLE msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:53.714:6) : proctitle=/sbin/auditctl -R /etc/audit/audit.rules 
type=SYSCALL msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:53.714:6) : arch=x86_64 syscall=sendto success=yes exit=60 a0=0x3 a1=0x7ffde2d79a90 a2=0x3c a3=0x0 items=0 ppid=1019 pid=1033 auid=unset uid=root gid=root euid=root suid=root fsuid=root egid=root sgid=root fsgid=root tty=(none) ses=unset comm=auditctl exe=/usr/sbin/auditctl subj=system_u:system_r:unconfined_service_t:s0 key=(null) 
type=CONFIG_CHANGE msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:53.714:6) : op=set audit_backlog_limit=8192 old=64 auid=unset ses=unset subj=system_u:system_r:unconfined_service_t:s0 res=yes 
----
type=PROCTITLE msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:53.731:7) : proctitle=/sbin/auditctl -R /etc/audit/audit.rules 
type=SYSCALL msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:53.731:7) : arch=x86_64 syscall=sendto success=yes exit=60 a0=0x3 a1=0x7ffde2d79a90 a2=0x3c a3=0x0 items=0 ppid=1019 pid=1033 auid=unset uid=root gid=root euid=root suid=root fsuid=root egid=root sgid=root fsgid=root tty=(none) ses=unset comm=auditctl exe=/usr/sbin/auditctl subj=system_u:system_r:unconfined_service_t:s0 key=(null) 
type=CONFIG_CHANGE msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:53.731:7) : op=set audit_failure=1 old=1 auid=unset ses=unset subj=system_u:system_r:unconfined_service_t:s0 res=yes 
----
type=PROCTITLE msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:53.734:8) : proctitle=/sbin/auditctl -R /etc/audit/audit.rules 
type=SYSCALL msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:53.734:8) : arch=x86_64 syscall=sendto success=yes exit=60 a0=0x3 a1=0x7ffde2d79a90 a2=0x3c a3=0x0 items=0 ppid=1019 pid=1033 auid=unset uid=root gid=root euid=root suid=root fsuid=root egid=root sgid=root fsgid=root tty=(none) ses=unset comm=auditctl exe=/usr/sbin/auditctl subj=system_u:system_r:unconfined_service_t:s0 key=(null) 
type=CONFIG_CHANGE msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:53.734:8) : op=set audit_backlog_wait_time=60000 old=60000 auid=unset ses=unset subj=system_u:system_r:unconfined_service_t:s0 res=yes 
----
type=SERVICE_START msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:53.755:9) : pid=1 uid=root auid=unset ses=unset subj=system_u:system_r:init_t:s0 msg='unit=auditd comm=systemd exe=/usr/lib/systemd/systemd hostname=? addr=? terminal=? res=success' 
----
type=SYSTEM_BOOT msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:53.767:10) : pid=1040 uid=root auid=unset ses=unset subj=system_u:system_r:init_t:s0 msg=' comm=systemd-update-utmp exe=/usr/lib/systemd/systemd-update-utmp hostname=? addr=? terminal=? res=success' 
----
type=SERVICE_START msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:53.771:11) : pid=1 uid=root auid=unset ses=unset subj=system_u:system_r:init_t:s0 msg='unit=systemd-update-utmp comm=systemd exe=/usr/lib/systemd/systemd hostname=? addr=? terminal=? res=success' 
----
type=SERVICE_START msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:54.173:12) : pid=1 uid=root auid=unset ses=unset subj=system_u:system_r:init_t:s0 msg='unit=ldconfig comm=systemd exe=/usr/lib/systemd/systemd hostname=? addr=? terminal=? res=success' 
----
type=SERVICE_START msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:54.205:13) : pid=1 uid=root auid=unset ses=unset subj=system_u:system_r:init_t:s0 msg='unit=systemd-update-done comm=systemd exe=/usr/lib/systemd/systemd hostname=? addr=? terminal=? res=success' 
----
type=SERVICE_START msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:54.216:14) : pid=1 uid=root auid=unset ses=unset subj=system_u:system_r:init_t:s0 msg='unit=irqbalance comm=systemd exe=/usr/lib/systemd/systemd hostname=? addr=? terminal=? res=success' 
----
type=PROCTITLE msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:56.750:76) : proctitle=/usr/sbin/ebtables-restore --noflush 
type=SYSCALL msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:56.750:76) : arch=x86_64 syscall=sendmsg success=yes exit=884 a0=0x3 a1=0x7ffec5f3a630 a2=0x0 a3=0x7ffec5f3a61c items=0 ppid=1157 pid=1518 auid=unset uid=root gid=root euid=root suid=root fsuid=root egid=root sgid=root fsgid=root tty=(none) ses=unset comm=ebtables-restor exe=/usr/sbin/xtables-nft-multi subj=system_u:system_r:iptables_t:s0 key=(null) 
type=NETFILTER_CFG msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:56.750:76) : table=nat:29 family=bridge entries=3 op=nft_register_chain pid=1518 subj=system_u:system_r:iptables_t:s0 comm=ebtables-restor 
type=NETFILTER_CFG msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:56.750:76) : table=filter:29 family=bridge entries=3 op=nft_register_chain pid=1518 subj=system_u:system_r:iptables_t:s0 comm=ebtables-restor 
----
type=PROCTITLE msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:56.755:77) : proctitle=/usr/libexec/platform-python -s /usr/sbin/firewalld --nofork --nopid 
type=SYSCALL msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:56.755:77) : arch=x86_64 syscall=sendmsg success=yes exit=172 a0=0x6 a1=0x7ffc55c4ce60 a2=0x0 a3=0x7ffc55c4bdac items=0 ppid=1 pid=1157 auid=unset uid=root gid=root euid=root suid=root fsuid=root egid=root sgid=root fsgid=root tty=(none) ses=unset comm=firewalld exe=/usr/libexec/platform-python3.6 subj=system_u:system_r:firewalld_t:s0 key=(null) 
type=NETFILTER_CFG msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:56.755:77) : table=firewalld:30 family=inet entries=1 op=nft_register_table pid=1157 subj=system_u:system_r:firewalld_t:s0 comm=firewalld 
type=NETFILTER_CFG msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:56.755:77) : table=firewalld:30 family=ipv4 entries=1 op=nft_register_table pid=1157 subj=system_u:system_r:firewalld_t:s0 comm=firewalld 
type=NETFILTER_CFG msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:56.755:77) : table=firewalld:30 family=ipv6 entries=1 op=nft_register_table pid=1157 subj=system_u:system_r:firewalld_t:s0 comm=firewalld 
----
type=PROCTITLE msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:56.798:79) : proctitle=/usr/libexec/platform-python -s /usr/sbin/firewalld --nofork --nopid 
type=SYSCALL msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:56.798:79) : arch=x86_64 syscall=sendmsg success=yes exit=32792 a0=0x6 a1=0x7ffc55c4ce60 a2=0x0 a3=0x7ffc55c4bdac items=0 ppid=1 pid=1157 auid=unset uid=root gid=root euid=root suid=root fsuid=root egid=root sgid=root fsgid=root tty=(none) ses=unset comm=firewalld exe=/usr/libexec/platform-python3.6 subj=system_u:system_r:firewalld_t:s0 key=(null) 
type=NETFILTER_CFG msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:56.798:79) : table=firewalld:31 family=inet entries=199 op=nft_register_chain pid=1157 subj=system_u:system_r:firewalld_t:s0 comm=firewalld 
type=NETFILTER_CFG msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:56.798:79) : table=firewalld:31 family=ipv4 entries=54 op=nft_register_chain pid=1157 subj=system_u:system_r:firewalld_t:s0 comm=firewalld 
type=NETFILTER_CFG msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:56.798:79) : table=firewalld:31 family=ipv6 entries=54 op=nft_register_chain pid=1157 subj=system_u:system_r:firewalld_t:s0 comm=firewalld 
----
type=SERVICE_START msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:56.871:78) : pid=1 uid=root auid=unset ses=unset subj=system_u:system_r:init_t:s0 msg='unit=libvirtd comm=systemd exe=/usr/lib/systemd/systemd hostname=? addr=? terminal=? res=success' 
----
type=PROCTITLE msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:57.255:80) : proctitle=/usr/sbin/iptables -w --table filter --new-chain LIBVIRT_INP 
type=SYSCALL msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:57.255:80) : arch=x86_64 syscall=sendmsg success=yes exit=128 a0=0x3 a1=0x7fffa8301bc0 a2=0x0 a3=0x7fffa8301bac items=0 ppid=1376 pid=1806 auid=unset uid=root gid=root euid=root suid=root fsuid=root egid=root sgid=root fsgid=root tty=(none) ses=unset comm=iptables exe=/usr/sbin/xtables-nft-multi subj=system_u:system_r:iptables_t:s0-s0:c0.c1023 key=(null) 
type=NETFILTER_CFG msg=audit(2022ë…„ 09ì›” 28ì¼ 01:42:57.255:80) : table=filter:35 family=ipv4 entries=1 op=nft_register_chain pid=1806 subj=system_u:system_r:iptables_t:s0-s0:c0.c1023 comm=iptables 
----
type=PROCTITLE msg=audit(2022ë…„ 09ì›” 28ì¼ 02:01:28.674:193) : proctitle=/usr/libexec/platform-python -s /usr/sbin/firewalld --nofork --nopid 
type=SYSCALL msg=audit(2022ë…„ 09ì›” 28ì¼ 02:01:28.674:193) : arch=x86_64 syscall=sendmsg success=yes exit=1880 a0=0x6 a1=0x7ffc55c4c400 a2=0x0 a3=0x7ffc55c4b34c items=0 ppid=1 pid=1157 auid=unset uid=root gid=root euid=root suid=root fsuid=root egid=root sgid=root fsgid=root tty=(none) ses=unset comm=firewalld exe=/usr/libexec/platform-python3.6 subj=system_u:system_r:firewalld_t:s0 key=(null) 
type=NETFILTER_CFG msg=audit(2022ë…„ 09ì›” 28ì¼ 02:01:28.674:193) : table=firewalld:86 family=inet entries=4 op=nft_register_rule pid=1157 subj=system_u:system_r:firewalld_t:s0 comm=firewalld 
type=NETFILTER_CFG msg=audit(2022ë…„ 09ì›” 28ì¼ 02:01:28.674:193) : table=firewalld:86 family=ipv4 entries=2 op=nft_register_rule pid=1157 subj=system_u:system_r:firewalld_t:s0 comm=firewalld 
type=NETFILTER_CFG msg=audit(2022ë…„ 09ì›” 28ì¼ 02:01:28.674:193) : table=firewalld:86 family=ipv6 entries=2 op=nft_register_rule pid=1157 subj=system_u:system_r:firewalld_t:s0 comm=firewalld 
----
type=SYSTEM_RUNLEVEL msg=audit(2022ë…„ 09ì›” 28ì¼ 02:57:59.212:146) : pid=2373 uid=root auid=unset ses=unset subj=system_u:system_r:init_t:s0 msg='old-level=N new-level=5 comm=systemd-update-utmp exe=/usr/lib/systemd/systemd-update-utmp hostname=? addr=? terminal=? res=success' 
----
type=SERVICE_START msg=audit(2022ë…„ 09ì›” 28ì¼ 02:57:59.214:147) : pid=1 uid=root auid=unset ses=unset subj=system_u:system_r:init_t:s0 msg='unit=systemd-update-utmp-runlevel comm=systemd exe=/usr/lib/systemd/systemd hostname=? addr=? terminal=? res=success' 
----
type=SERVICE_STOP msg=audit(2022ë…„ 09ì›” 28ì¼ 02:57:59.214:148) : pid=1 uid=root auid=unset ses=unset subj=system_u:system_r:init_t:s0 msg='unit=systemd-update-utmp-runlevel comm=systemd exe=/usr/lib/systemd/systemd hostname=? addr=? terminal=? res=success' 
----
type=USER_AUTH msg=audit(2022ë…„ 09ì›” 28ì¼ 02:58:04.001:149) : pid=2375 uid=root auid=unset ses=unset subj=system_u:system_r:xdm_t:s0-s0:c0.c1023 msg='op=PAM:authentication grantors=pam_usertype,pam_localuser,pam_unix,pam_gnome_keyring acct=ahnlab exe=/usr/libexec/gdm-session-worker hostname=localhost.localdomain addr=? terminal=/dev/tty1 res=success' 
----
type=USER_ACCT msg=audit(2022ë…„ 09ì›” 28ì¼ 02:58:04.006:150) : pid=2375 uid=root auid=unset ses=unset subj=system_u:system_r:xdm_t:s0-s0:c0.c1023 msg='op=PAM:accounting grantors=pam_unix,pam_localuser acct=ahnlab exe=/usr/libexec/gdm-session-worker hostname=localhost.localdomain addr=? terminal=/dev/tty1 res=success' 
----
type=CRED_ACQ msg=audit(2022ë…„ 09ì›” 28ì¼ 02:58:04.011:151) : pid=2375 uid=root auid=unset ses=unset subj=system_u:system_r:xdm_t:s0-s0:c0.c1023 msg='op=PAM:setcred grantors=pam_localuser,pam_unix,pam_gnome_keyring acct=ahnlab exe=/usr/libexec/gdm-session-worker hostname=localhost.localdomain addr=? terminal=/dev/tty1 res=success' 
----
type=LOGIN msg=audit(2022ë…„ 09ì›” 28ì¼ 02:58:04.018:152) : pid=2375 uid=root subj=system_u:system_r:xdm_t:s0-s0:c0.c1023 old-auid=unset auid=ahnlab tty=(none) old-ses=4294967295 ses=2 res=yes 
----
type=PROCTITLE msg=audit(2022ë…„ 09ì›” 28ì¼ 02:58:04.018:152) : proctitle=gdm-session-worker [pam/gdm-password] 
type=SYSCALL msg=audit(2022ë…„ 09ì›” 28ì¼ 02:58:04.018:152) : arch=x86_64 syscall=write success=yes exit=4 a0=0xa a1=0x7ffe1f2a26c0 a2=0x4 a3=0x0 items=0 ppid=1238 pid=2375 auid=ahnlab uid=root gid=ahnlab euid=root suid=root fsuid=root egid=ahnlab sgid=ahnlab fsgid=ahnlab tty=(none) ses=2 comm=gdm-session-wor exe=/usr/libexec/gdm-session-worker subj=system_u:system_r:xdm_t:s0-s0:c0.c1023 key=(null) 
----
type=USER_ROLE_CHANGE msg=audit(2022ë…„ 09ì›” 28ì¼ 02:58:04.031:153) : pid=2375 uid=root auid=ahnlab ses=2 subj=system_u:system_r:xdm_t:s0-s0:c0.c1023 msg='pam: default-context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 selected-context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 exe=/usr/libexec/gdm-session-worker hostname=localhost.localdomain addr=? terminal=/dev/tty2 res=success' 
----
type=SERVICE_START msg=audit(2022ë…„ 09ì›” 28ì¼ 02:58:04.063:154) : pid=1 uid=root auid=unset ses=unset subj=system_u:system_r:init_t:s0 msg='unit=user-runtime-dir@1000 comm=systemd exe=/usr/lib/systemd/systemd hostname=? addr=? terminal=? res=success' 
----
type=USER_ACCT msg=audit(2022ë…„ 09ì›” 28ì¼ 02:58:04.084:155) : pid=2387 uid=root auid=unset ses=unset subj=system_u:system_r:init_t:s0 msg='op=PAM:accounting grantors=pam_unix acct=ahnlab exe=/usr/lib/systemd/systemd hostname=? addr=? terminal=? res=success' 
----
type=USER_ROLE_CHANGE msg=audit(2022ë…„ 09ì›” 28ì¼ 02:58:04.084:156) : pid=2387 uid=root auid=unset ses=unset subj=system_u:system_r:init_t:s0 msg='pam: default-context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 selected-context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 exe=/usr/lib/systemd/systemd hostname=? addr=? terminal=? res=success' 
----
type=USER_LOGIN msg=audit(2022ë…„ 09ì›” 28ì¼ 05:35:46.992:299) : pid=7789 uid=root auid=ahnlab ses=5 subj=system_u:system_r:sshd_t:s0-s0:c0.c1023 msg='op=login id=ahnlab exe=/usr/sbin/sshd hostname=? addr=192.168.66.1 terminal=ssh res=success' 
----
type=USER_START msg=audit(2022ë…„ 09ì›” 28ì¼ 05:35:46.992:300) : pid=7789 uid=root auid=ahnlab ses=5 subj=system_u:system_r:sshd_t:s0-s0:c0.c1023 msg='op=login id=ahnlab exe=/usr/sbin/sshd hostname=? addr=192.168.66.1 terminal=ssh res=success' 
----
type=CRYPTO_KEY_USER msg=audit(2022ë…„ 09ì›” 28ì¼ 05:35:47.006:301) : pid=7789 uid=root auid=ahnlab ses=5 subj=system_u:system_r:sshd_t:s0-s0:c0.c1023 msg='op=destroy kind=server fp=SHA256:3b:04:1b:5b:09:fb:ec:42:8b:65:f7:08:59:1f:6d:40:16:2a:c1:71:2b:4d:e8:5f:c1:bf:4e:ae:6b:b3:af:a8 direction=? spid=7797 suid=ahnlab  exe=/usr/sbin/sshd hostname=? addr=? terminal=? res=success' 
----
type=CRYPTO_KEY_USER msg=audit(2022ë…„ 09ì›” 28ì¼ 05:35:47.334:302) : pid=7789 uid=root auid=ahnlab ses=5 subj=system_u:system_r:sshd_t:s0-s0:c0.c1023 msg='op=destroy kind=session fp=? direction=both spid=7794 suid=ahnlab rport=54041 laddr=192.168.66.130 lport=22  exe=/usr/sbin/sshd hostname=? addr=192.168.66.1 terminal=? res=success' 
----
type=CRYPTO_KEY_USER msg=audit(2022ë…„ 09ì›” 28ì¼ 05:35:47.339:303) : pid=7789 uid=root auid=ahnlab ses=5 subj=system_u:system_r:sshd_t:s0-s0:c0.c1023 msg='op=destroy kind=server fp=SHA256:3b:04:1b:5b:09:fb:ec:42:8b:65:f7:08:59:1f:6d:40:16:2a:c1:71:2b:4d:e8:5f:c1:bf:4e:ae:6b:b3:af:a8 direction=? spid=7794 suid=ahnlab  exe=/usr/sbin/sshd hostname=? addr=? terminal=? res=success' 
----
type=USER_END msg=audit(2022ë…„ 09ì›” 28ì¼ 05:35:47.351:304) : pid=7789 uid=root auid=ahnlab ses=5 subj=system_u:system_r:sshd_t:s0-s0:c0.c1023 msg='op=PAM:session_close grantors=pam_selinux,pam_loginuid,pam_selinux,pam_namespace,pam_keyinit,pam_keyinit,pam_limits,pam_systemd,pam_unix,pam_umask,pam_lastlog acct=ahnlab exe=/usr/sbin/sshd hostname=192.168.66.1 addr=192.168.66.1 terminal=ssh res=success' 
----
type=CRED_DISP msg=audit(2022ë…„ 09ì›” 28ì¼ 05:35:47.352:305) : pid=7789 uid=root auid=ahnlab ses=5 subj=system_u:system_r:sshd_t:s0-s0:c0.c1023 msg='op=PAM:setcred grantors=pam_localuser,pam_unix acct=ahnlab exe=/usr/sbin/sshd hostname=192.168.66.1 addr=192.168.66.1 terminal=ssh res=success' 
----
type=USER_END msg=audit(2022ë…„ 09ì›” 28ì¼ 05:35:47.358:306) : pid=7789 uid=root auid=ahnlab ses=5 subj=system_u:system_r:sshd_t:s0-s0:c0.c1023 msg='op=login id=ahnlab exe=/usr/sbin/sshd hostname=? addr=192.168.66.1 terminal=ssh res=success' 
----
type=USER_LOGOUT msg=audit(2022ë…„ 09ì›” 28ì¼ 05:35:47.359:307) : pid=7789 uid=root auid=ahnlab ses=5 subj=system_u:system_r:sshd_t:s0-s0:c0.c1023 msg='op=login id=ahnlab exe=/usr/sbin/sshd hostname=? addr=192.168.66.1 terminal=ssh res=success' 
</code></pre>
</section>

</div>
      
<div class="line top"></div>
<div class="line bottom"></div>
<div class="line left"></div>
<div class="line right"></div>

    </div>
<script type="text/javascript" src=/reveal-hugo/object-assign.js></script>

<a href="/reveal-js/css/print/" id="print-location" style="display: none;"></a>
<script type="text/javascript">
  var printLocationElement = document.getElementById('print-location');
  var link = document.createElement('link');
  link.rel = 'stylesheet';
  link.type = 'text/css';
  link.href = printLocationElement.href + (window.location.search.match(/print-pdf/gi) ? 'pdf.css' : 'paper.css');
  document.getElementsByTagName('head')[0].appendChild(link);
</script>

<script type="application/json" id="reveal-hugo-site-params">{"history":true,"templates":{"grey":{"background":"#424242","transition":"convex"}}}</script>
<script type="application/json" id="reveal-hugo-page-params">{"custom_theme":"reveal-hugo/themes/robot-lung.css","highlight_theme":"color-brewer","margin":0.2,"templates":{"hotpink":{"background":"#FF4081","class":"hotpink"}},"transition":"slide","transition_speed":"fast"}</script>

<script src="/reveal-js/js/reveal.js"></script>

<script type="text/javascript">
  
  
  function camelize(map) {
    if (map) {
      Object.keys(map).forEach(function(k) {
        newK = k.replace(/(\_\w)/g, function(m) { return m[1].toUpperCase() });
        if (newK != k) {
          map[newK] = map[k];
          delete map[k];
        }
      });
    }
    return map;
  }
  
  var revealHugoDefaults = { center: true, controls: true, history: true, progress: true, transition: "slide" };
  var revealHugoSiteParams = JSON.parse(document.getElementById('reveal-hugo-site-params').innerHTML);
  var revealHugoPageParams = JSON.parse(document.getElementById('reveal-hugo-page-params').innerHTML);
  
  var options = Object.assign({},
    camelize(revealHugoDefaults),
    camelize(revealHugoSiteParams),
    camelize(revealHugoPageParams));
  Reveal.initialize(options);
</script>


  
  
  <script type="text/javascript" src="/reveal-js/plugin/markdown/marked.js"></script>
  
  <script type="text/javascript" src="/reveal-js/plugin/markdown/markdown.js"></script>
  
  <script type="text/javascript" src="/reveal-js/plugin/highlight/highlight.js"></script>
  
  <script type="text/javascript" src="/reveal-js/plugin/zoom-js/zoom.js"></script>
  
  
  <script type="text/javascript" src="/reveal-js/plugin/notes/notes.js"></script>



















  <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
  <script>
    mermaid.initialize({startOnLoad: false});
    let render = (event) => {
      let mermaidElems = event.currentSlide.querySelectorAll('.mermaid');
      if (!mermaidElems.length){
          return
      }
      mermaidElems.forEach(mermaidElem => {
          let processed = mermaidElem.getAttribute('data-processed');
          if (!processed){
              
              mermaid.init(undefined, mermaidElem);
          }
      });
    };
    Reveal.addEventListener('slidechanged', render);
    Reveal.addEventListener('ready', render);
  </script>

    
    


<script type="text/javascript">

Reveal.addEventListener('slidechanged', function(event) {
  console.log("ğŸï¸ Slide is now " + event.indexh);
});
</script>

  </body>
</html>
